<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HeyGen Streaming Avatar Viewer (Custom Mode)</title>

  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background: #0b0b0b; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .frame { position: relative; width: 100%; height: 760px; background: #000; border-radius: 22px; overflow: hidden; }
    video { width: 100%; height: 100%; object-fit: cover; background: #000; }
    .hud { position: absolute; left: 16px; right: 16px; bottom: 16px; background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.12); border-radius: 18px; padding: 14px; }
    .topbar { position:absolute; left: 16px; top: 14px; font-size: 28px; font-weight: 650; color: #fff; text-shadow: 0 2px 10px rgba(0,0,0,0.65); }
    .badges { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom: 10px; }
    .badge { padding: 8px 12px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.10); color: #cfd3d8; font-size: 14px; }
    .badge.good { color: #7ef29d; }
    .badge.bad { color: #ff8b8b; }
    .btns { display:flex; gap: 10px; margin: 10px 0; flex-wrap: wrap; }
    button { appearance:none; border:none; padding: 10px 14px; border-radius: 14px; background: rgba(255,255,255,0.10); color:#fff; font-size: 16px; cursor:pointer; }
    button:hover { background: rgba(255,255,255,0.15); }
    .log { max-height: 190px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 13px; line-height: 1.35; color: #d6d6d6; white-space: pre-wrap; }
  </style>
</head>

<body>
  <div class="frame">
    <div class="topbar" id="title">Live session</div>
    <video id="avatarVideo" autoplay playsinline></video>

    <div class="hud">
      <div class="badges">
        <div class="badge" id="webrtcBadge">WebRTC: idle</div>
        <div class="badge" id="startBadge">Start: pending</div>
        <div class="badge" id="audioBadge">Audio: pending</div>
        <div class="badge" id="trackBadge">Tracks: 0</div>
      </div>

      <div class="btns">
        <button id="reconnectBtn">Reconnect</button>
        <button id="speakBtn">Speak (repeat)</button>
        <button id="interruptBtn">Interrupt</button>
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

<script>
  const PAYLOAD = /*__PAYLOAD__*/;

  const logEl = document.getElementById("log");
  const webrtcBadge = document.getElementById("webrtcBadge");
  const startBadge = document.getElementById("startBadge");
  const audioBadge = document.getElementById("audioBadge");
  const trackBadge = document.getElementById("trackBadge");
  const titleEl = document.getElementById("title");
  const videoEl = document.getElementById("avatarVideo");

  titleEl.textContent = (PAYLOAD.avatar_name || "Avatar") + " · Live session";

  function ts() {
    const d = new Date();
    return d.toTimeString().slice(0,8);
  }
  function addLog(msg) {
    logEl.textContent += `[${ts()}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setBadge(el, label, state) {
    el.textContent = label;
    el.classList.remove("good","bad");
    if (state === "good") el.classList.add("good");
    if (state === "bad") el.classList.add("bad");
  }

  function authHeaders() {
    const h = { "content-type": "application/json", "accept": "application/json" };
    if (PAYLOAD.auth_mode === "bearer") h["Authorization"] = "Bearer " + PAYLOAD.api_key;
    else h["X-Api-Key"] = PAYLOAD.api_key;
    return h;
  }

  addLog("Viewer boot.");
  addLog("Payload: nonce=" + PAYLOAD.nonce);
  addLog("Session: " + PAYLOAD.session_id);
  addLog("Offer: type=" + (PAYLOAD.offer && PAYLOAD.offer.type) + " sdp_len=" + ((PAYLOAD.offer && PAYLOAD.offer.sdp) ? PAYLOAD.offer.sdp.length : 0));

  let pc = null;
  let remoteAudioEl = null;
  let trackCount = 0;

  function updateTracks() {
    trackBadge.textContent = "Tracks: " + trackCount;
  }

  function cleanup() {
    try { if (remoteAudioEl) remoteAudioEl.remove(); } catch {}
    remoteAudioEl = null;

    try { if (pc) pc.close(); } catch {}
    pc = null;

    trackCount = 0;
    updateTracks();

    setBadge(webrtcBadge, "WebRTC: idle", null);
    setBadge(startBadge, "Start: pending", null);
    setBadge(audioBadge, "Audio: pending", null);
  }

  async function connectWebRTCAndStart() {
    cleanup();

    try {
      setBadge(webrtcBadge, "WebRTC: creating…", null);

      const delay = Number(PAYLOAD.connect_delay_ms || 0);
      if (delay > 0) { addLog("Connect delay: waiting " + delay + "ms…"); await new Promise(r=>setTimeout(r,delay)); }

      pc = new RTCPeerConnection({
        iceServers: Array.isArray(PAYLOAD.ice_servers) ? PAYLOAD.ice_servers : []
      });

      pc.oniceconnectionstatechange = () => {
        addLog("ICE state: " + pc.iceConnectionState);
      };

      pc.ontrack = (ev) => {
        const track = ev.track;
        addLog("ontrack: kind=" + track.kind);
        trackCount += 1;
        updateTracks();

        if (track.kind === "video") {
          // attach video
          const stream = ev.streams && ev.streams[0] ? ev.streams[0] : new MediaStream([track]);
          videoEl.srcObject = stream;
          videoEl.muted = true; // keep muted; audio handled separately
          videoEl.play().catch(()=>{});
        }

        if (track.kind === "audio") {
          // attach audio
          const stream = ev.streams && ev.streams[0] ? ev.streams[0] : new MediaStream([track]);
          if (!remoteAudioEl) {
            remoteAudioEl = document.createElement("audio");
            remoteAudioEl.autoplay = true;
            remoteAudioEl.controls = false;
            remoteAudioEl.style.display = "none";
            document.body.appendChild(remoteAudioEl);
          }
          remoteAudioEl.srcObject = stream;
          remoteAudioEl.play().catch(()=>{});
          setBadge(audioBadge, "Audio: attached", "good");
        }
      };

      // 1) Apply offer from streaming.new
      await pc.setRemoteDescription(PAYLOAD.offer);
      addLog("RemoteDescription set (offer).");

      // 2) Create & set answer
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      addLog("LocalDescription set (answer). sdp_len=" + (answer.sdp ? answer.sdp.length : 0));

      setBadge(webrtcBadge, "WebRTC: ready", "good");

      // 3) Call streaming.start with answer SDP
      setBadge(startBadge, "Start: sending…", null);

      const startUrl = PAYLOAD.api_base + "/streaming.start";
      const startPayload = {
        session_id: PAYLOAD.session_id,
        sdp: { type: "answer", sdp: answer.sdp }
      };

      addLog("POST " + startUrl + " (sending answer) …");
      const r = await fetch(startUrl, {
        method: "POST",
        headers: authHeaders(),
        body: JSON.stringify(startPayload)
      });

      const txt = await r.text();
      addLog("Start HTTP " + r.status + " body=" + (txt ? txt.slice(0, 500) : ""));

      if (!r.ok) {
        setBadge(startBadge, "Start: failed", "bad");
        throw new Error("streaming.start failed: " + r.status);
      }

      setBadge(startBadge, "Start: OK", "good");
      addLog("Started.");

    } catch (e) {
      setBadge(webrtcBadge, "WebRTC: error", "bad");
      setBadge(startBadge, "Start: error", "bad");
      addLog("ERROR: " + (e && e.message ? e.message : String(e)));
    }
  }

  async function doInterrupt() {
    try {
      const url = PAYLOAD.api_base + "/streaming.interrupt";
      addLog("POST " + url);
      const r = await fetch(url, {
        method: "POST",
        headers: authHeaders(),
        body: JSON.stringify({ session_id: PAYLOAD.session_id })
      });
      const txt = await r.text();
      addLog("Interrupt HTTP " + r.status + " body=" + (txt ? txt.slice(0, 300) : ""));
    } catch (e) {
      addLog("Interrupt error: " + (e && e.message ? e.message : String(e)));
    }
  }

  async function speakRepeat(text) {
    try {
      const t = String(text || "").trim();
      if (!t) { addLog("Speak blocked: empty text."); return; }

      if (PAYLOAD.do_interrupt) {
        addLog("Auto: interrupt before speak…");
        await doInterrupt();
        const ms = Number(PAYLOAD.interrupt_delay_ms || 0);
        if (ms > 0) { addLog("Delay " + ms + "ms…"); await new Promise(r=>setTimeout(r, ms)); }
      }

      const url = PAYLOAD.api_base + "/streaming.task";
      const payload = {
        session_id: PAYLOAD.session_id,
        text: t,
        task_type: "repeat",
        task_mode: "sync"
      };

      addLog("POST " + url + " task_type=repeat chars=" + t.length);
      const r = await fetch(url, {
        method: "POST",
        headers: authHeaders(),
        body: JSON.stringify(payload)
      });
      const txt = await r.text();
      addLog("Task HTTP " + r.status + " body=" + (txt ? txt.slice(0, 500) : ""));

      if (!r.ok) addLog("Task failed (non-200).");
      else addLog("Task sent OK.");

    } catch (e) {
      addLog("Speak error: " + (e && e.message ? e.message : String(e)));
    }
  }

  document.getElementById("reconnectBtn").addEventListener("click", async () => {
    addLog("Reconnect pressed.");
    await connectWebRTCAndStart();
  });

  document.getElementById("interruptBtn").addEventListener("click", async () => {
    addLog("Interrupt pressed.");
    await doInterrupt();
  });

  document.getElementById("speakBtn").addEventListener("click", async () => {
    addLog("Speak pressed.");
    await speakRepeat(PAYLOAD.default_text || "Hello");
  });

  // Auto-connect
  connectWebRTCAndStart();
</script>
</body>
</html>
