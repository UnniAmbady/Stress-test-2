<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HeyGen Streaming Avatar Viewer (Custom Mode)</title>

  <!-- LiveKit SDK (UMD). Note: Some environments block external scripts in iframes. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/livekit-client/2.15.7/livekit-client.umd.min.js"></script>

  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background: #0b0b0b; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .frame { position: relative; width: 100%; height: 760px; background: #000; border-radius: 22px; overflow: hidden; }
    video { width: 100%; height: 100%; object-fit: cover; background: #000; }
    .hud { position: absolute; left: 16px; right: 16px; bottom: 16px; background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.12); border-radius: 18px; padding: 14px; }
    .topbar { position:absolute; left: 16px; top: 14px; font-size: 28px; font-weight: 650; color: #fff; text-shadow: 0 2px 10px rgba(0,0,0,0.65); }
    .badges { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom: 10px; }
    .badge { padding: 8px 12px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.10); color: #cfd3d8; font-size: 14px; }
    .badge.good { color: #7ef29d; }
    .badge.bad { color: #ff8b8b; }
    .btns { display:flex; gap: 10px; margin: 10px 0; }
    button { appearance:none; border:none; padding: 10px 14px; border-radius: 14px; background: rgba(255,255,255,0.10); color:#fff; font-size: 16px; cursor:pointer; }
    button:hover { background: rgba(255,255,255,0.15); }
    .log { max-height: 160px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 13px; line-height: 1.35; color: #d6d6d6; white-space: pre-wrap; }
    .muted { opacity: 0.9; }
  </style>
</head>

<body>
  <div class="frame">
    <div class="topbar" id="title">Live session</div>
    <video id="avatarVideo" autoplay playsinline></video>

    <div class="hud">
      <div class="badges">
        <div class="badge" id="sdkBadge">SDK: checking…</div>
        <div class="badge" id="roomBadge">Room: idle</div>
        <div class="badge" id="micBadge">Mic: off</div>
        <div class="badge" id="trackBadge">Tracks: 0</div>
      </div>

      <div class="btns">
        <button id="reconnectBtn">Reconnect</button>
        <button id="micBtn">Enable Mic</button>
        <button id="speakBtn">Speak</button>
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

<script>
  // Payload injected by Streamlit (do not rename placeholder)
  const PAYLOAD = /*__PAYLOAD__*/;

  const logEl = document.getElementById("log");
  const sdkBadge = document.getElementById("sdkBadge");
  const roomBadge = document.getElementById("roomBadge");
  const micBadge = document.getElementById("micBadge");
  const trackBadge = document.getElementById("trackBadge");
  const titleEl = document.getElementById("title");
  const videoEl = document.getElementById("avatarVideo");

  titleEl.textContent = (PAYLOAD.avatar_name || "Avatar") + " · Live session";

  function ts() {
    const d = new Date();
    return d.toTimeString().slice(0,8);
  }
  function addLog(msg) {
    logEl.textContent += `[${ts()}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setBadge(el, label, state) {
    el.textContent = label;
    el.classList.remove("good","bad");
    if (state === "good") el.classList.add("good");
    if (state === "bad") el.classList.add("bad");
  }

  addLog("Viewer boot.");
  addLog("Payload: nonce=" + PAYLOAD.nonce);

  // LiveKit UMD exposes either LivekitClient or livekit (depending on build/CDN)
  function findLiveKitSDK() {
    if (window.LivekitClient) return window.LivekitClient;
    if (window.livekit) return window.livekit;
    if (window.LiveKitClient) return window.LiveKitClient;
    return null;
  }

  const SDK = findLiveKitSDK();
  if (!SDK) {
    setBadge(sdkBadge, "SDK: missing", "bad");
    setBadge(roomBadge, "Room: SDK missing", "bad");
    addLog("LiveKit SDK missing in iframe. Check CDN / CSP.");
  } else {
    setBadge(sdkBadge, "SDK: loaded", "good");
    addLog("LiveKit SDK found.");
  }

  let room = null;
  let micTrack = null;

  function updateTracks() {
    try {
      if (!room) { trackBadge.textContent = "Tracks: 0"; return; }
      const count = room.remoteParticipants ? Array.from(room.remoteParticipants.values()).reduce((acc,p)=>acc + p.trackPublications.size,0) : 0;
      trackBadge.textContent = "Tracks: " + count;
    } catch { /* ignore */ }
  }

  async function connect() {
    if (!SDK) return;
    try {
      setBadge(roomBadge, "Room: connecting…", null);
      addLog("Connecting to LiveKit…");
      addLog("URL: " + PAYLOAD.livekit_url);
      addLog("Token length: " + (PAYLOAD.livekit_token ? PAYLOAD.livekit_token.length : 0));
      const delay = Number(PAYLOAD.connect_delay_ms || 0);
      if (delay > 0) { addLog("Connect delay: waiting " + delay + "ms…"); await new Promise(r=>setTimeout(r,delay)); }

      room = new SDK.Room({
        adaptiveStream: true,
        dynacast: true,
      });

      room.on("trackSubscribed", (track, publication, participant) => {
        addLog(`TrackSubscribed: kind=${track.kind}, from=${participant.identity}`);
        if (track.kind === "video") {
          const el = track.attach();
          el.autoplay = true;
          el.playsInline = true;
          el.muted = true; // avoid autoplay policies; we only need avatar audio track separately
          el.style.width = "100%";
          el.style.height = "100%";
          el.style.objectFit = "cover";
          // replace current video
          videoEl.replaceWith(el);
          el.id = "avatarVideo";
          addLog("Attached avatar video.");
        } else if (track.kind === "audio") {
          const audioEl = track.attach();
          audioEl.autoplay = true;
          audioEl.controls = false;
          audioEl.style.display = "none";
          document.body.appendChild(audioEl);
          addLog("Attached avatar audio.");
        }
        updateTracks();
      });

      room.on("disconnected", () => {
        setBadge(roomBadge, "Room: disconnected", "bad");
        addLog("Disconnected.");
      });

      await room.connect(PAYLOAD.livekit_url, PAYLOAD.livekit_token);
      setBadge(roomBadge, "Room: connected", "good");
      addLog("Connected.");
      updateTracks();

      if (PAYLOAD.auto_enable_mic) {
        addLog("Auto: enabling mic …");
        await enableMic();
      }
    } catch (e) {
      setBadge(roomBadge, "Room: error", "bad");
      addLog("Connect error: " + (e && e.message ? e.message : String(e)));
    }
  }

  async function enableMic() {
    if (!SDK || !room) { addLog("Mic: room not ready."); return; }
    try {
      if (micTrack) { addLog("Mic already enabled."); return; }
      micTrack = await SDK.createLocalAudioTrack();
      await room.localParticipant.publishTrack(micTrack);
      setBadge(micBadge, "Mic: ON", "good");
      addLog("Local microphone published.");
    } catch (e) {
      setBadge(micBadge, "Mic: error", "bad");
      addLog("Mic error: " + (e && e.message ? e.message : String(e)));
    }
  }

  // In Custom mode, speech is controlled via HeyGen REST streaming.task (task_type=repeat).
  // The "Speak" button here is only a UX helper: it posts a message to parent (Streamlit) so the backend can call streaming.task.
  function requestSpeak() {
    addLog("Speak pressed. Asking parent to send streaming.task …");
    window.parent.postMessage({ type: "HEYGEN_SPEAK_REQUEST", nonce: PAYLOAD.nonce }, "*");
  }

  document.getElementById("reconnectBtn").addEventListener("click", async () => {
    addLog("Reconnect pressed.");
    try { if (room) await room.disconnect(); } catch {}
    room = null;
    await connect();
  });

  document.getElementById("micBtn").addEventListener("click", async () => {
    addLog("Enable Mic pressed.");
    await enableMic();
  });

  document.getElementById("speakBtn").addEventListener("click", () => requestSpeak());

  // Auto-connect
  connect();
</script>
</body>
</html>
