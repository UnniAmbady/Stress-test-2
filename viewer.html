<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>__AVATAR_NAME__ · Live session</title>

  <!-- LiveKit JS SDK (UMD) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/livekit-client/2.15.7/livekit-client.umd.min.js"></script>

  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background: #0b0b0b; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { padding: 12px; display: flex; flex-direction: column; gap: 10px; align-items: center; }
    .title { color: #e9e9e9; font-size: 14px; opacity: 0.95; }
    .stage { width: 100%; max-width: 760px; aspect-ratio: 16/9; background: #111; border-radius: 18px; overflow: hidden; position: relative; }
    video { width: 100%; height: 100%; object-fit: cover; background: #111; }
    .panel { width: 100%; max-width: 760px; background: rgba(0,0,0,.55); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 10px; color: #eee; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .pill { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,.10); font-size: 12px; }
    .ok { color: #a6ffcf; }
    .bad { color: #ff6b6b; }
    .warn { color: #ffd166; }
    button { border: 0; border-radius: 999px; padding: 7px 12px; background: rgba(255,255,255,.14); color: #eee; cursor: pointer; }
    button:hover { background: rgba(255,255,255,.20); }
    .log { margin-top: 10px; max-height: 180px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; line-height: 1.35; white-space: pre-wrap; }
  </style>
</head>

<body>
<div class="wrap">
  <div class="title"><b>__AVATAR_NAME__</b> · Live session</div>

  <div class="stage">
    <video id="avatarVideo" autoplay playsinline></video>
  </div>

  <div class="panel">
    <div class="row">
      <span id="sdkPill" class="pill">SDK: ?</span>
      <span id="roomPill" class="pill">Room: ?</span>
      <span id="tracksPill" class="pill">Tracks: 0</span>
      <button id="reconnectBtn">Reconnect</button>
      <button id="speakBtn">Speak</button>
    </div>
    <div class="log" id="log"></div>
  </div>
</div>

<script>
(function () {
  const LIVEKIT_URL = "__LIVEKIT_URL__";
  const LIVEKIT_TOKEN = "__LIVEKIT_TOKEN__";
  const PAYLOAD = __PAYLOAD_JSON__;

  const sdkPill = document.getElementById("sdkPill");
  const roomPill = document.getElementById("roomPill");
  const tracksPill = document.getElementById("tracksPill");
  const logEl = document.getElementById("log");
  const videoEl = document.getElementById("avatarVideo");

  const enc = new TextEncoder();

  function ts() {
    const d = new Date();
    return d.toLocaleTimeString();
  }
  function log(msg) {
    logEl.textContent += `[${ts()}] ${msg}\n`;
    logEl.scrollTop = 1e9;
  }
  function pill(el, text, cls) {
    el.textContent = text;
    el.className = "pill " + (cls || "");
  }

  // LiveKit UMD global detection
  const LK = window.LiveKitClient || window.LiveKit || window.livekit || window.livekitClient;
  if (!LK) {
    pill(sdkPill, "SDK: missing", "bad");
    pill(roomPill, "Room: SDK missing", "bad");
    log("LiveKit SDK missing in iframe. Check CDN / CSP.");
    return;
  }
  pill(sdkPill, "SDK: loaded", "ok");

  let room = null;
  let tracks = 0;
  let localMicTrack = null;

  function buildCommand(eventName, dataObj) {
    // Most LiveAvatar examples accept {type: "<event>", ...data}
    // We keep it conservative, but also include a nested "data" for compatibility.
    return {
      type: eventName,
      event: eventName,
      data: dataObj || {}
    };
  }

  async function publishCommand(eventName, dataObj) {
    if (!room) {
      log("Publish blocked: room not connected.");
      return;
    }
    const msg = buildCommand(eventName, dataObj);
    const bytes = enc.encode(JSON.stringify(msg));
    await room.localParticipant.publishData(bytes, { reliable: true });
    log(`Command sent: ${eventName} (bytes=${bytes.length})`);
  }

  async function ensureMicPublished() {
    if (!PAYLOAD.publish_microphone) {
      log("Mic publish disabled by payload.");
      return;
    }
    if (localMicTrack) {
      log("Mic already published.");
      return;
    }
    try {
      log("Requesting microphone…");
      // createLocalAudioTrack prompts for permission
      localMicTrack = await LK.createLocalAudioTrack();
      await room.localParticipant.publishTrack(localMicTrack);
      log("Microphone published (audio only).");
    } catch (e) {
      log("Mic error: " + (e && e.message ? e.message : e));
    }
  }

  async function connect() {
    try {
      pill(roomPill, "Room: connecting", "warn");
      log("Viewer boot.");
      log(`Payload: nonce=${PAYLOAD.nonce}`);

      room = new LK.Room();
      room.on(LK.RoomEvent.Disconnected, () => {
        pill(roomPill, "Room: disconnected", "bad");
        log("Disconnected.");
      });

      room.on(LK.RoomEvent.TrackSubscribed, (track, pub, participant) => {
        tracks += 1;
        tracksPill.textContent = `Tracks: ${tracks}`;
        log(`TrackSubscribed: kind=${track.kind}, from=${participant.identity}`);

        if (track.kind === "video") {
          track.attach(videoEl);
          log("Attached avatar video.");
        } else if (track.kind === "audio") {
          const a = document.createElement("audio");
          a.autoplay = true;
          track.attach(a);
          log("Attached avatar audio.");
        }
      });

      room.on(LK.RoomEvent.DataReceived, (payload, participant) => {
        try {
          const txt = new TextDecoder().decode(payload);
          log(`DataReceived from=${participant?.identity || "unknown"} bytes=${payload.length} txt=${txt.slice(0,160)}`);
        } catch (_) {
          log(`DataReceived from=${participant?.identity || "unknown"} bytes=${payload.length}`);
        }
      });

      log("Connecting to LiveKit…");
      log("URL: " + LIVEKIT_URL);
      log("Token length: " + (LIVEKIT_TOKEN ? LIVEKIT_TOKEN.length : 0));

      await room.connect(LIVEKIT_URL, LIVEKIT_TOKEN, { autoSubscribe: true });
      pill(roomPill, "Room: connected", "ok");
      log("Connected.");

      await ensureMicPublished();
    } catch (e) {
      pill(roomPill, "Room: error", "bad");
      log("Connect error: " + (e && e.message ? e.message : e));
    }
  }

  async function speakFlow(text) {
    // The requested experiment:
    // interrupt -> wait 500ms -> speak_text
    try {
      if (PAYLOAD.interrupt_before_speak) {
        await publishCommand("avatar.interrupt", {});
        const d = Number(PAYLOAD.interrupt_delay_ms || 500);
        log(`Sleep ${d}ms…`);
        await new Promise((res) => setTimeout(res, d));
      }
      await publishCommand("avatar.speak_text", { text: String(text || "") });
    } catch (e) {
      log("SpeakFlow error: " + (e && e.message ? e.message : e));
    }
  }

  document.getElementById("reconnectBtn").addEventListener("click", async () => {
    log("Reconnect pressed.");
    try { if (room) await room.disconnect(); } catch (_) {}
    room = null;
    tracks = 0;
    tracksPill.textContent = "Tracks: 0";
    await connect();
  });

  document.getElementById("speakBtn").addEventListener("click", async () => {
    if (!room) return log("Speak blocked: room not connected.");
    await ensureMicPublished();
    const text = (PAYLOAD && typeof PAYLOAD.text === "string") ? PAYLOAD.text : "";
    log(`Speak pressed. text_chars=${text.length}`);
    await speakFlow(text);
  });

  // Auto-run on connect if nonce > 0 (i.e., Streamlit button pressed)
  connect().then(async () => {
    const nonce = Number(PAYLOAD.nonce || 0);
    if (nonce > 0) {
      // Give a small settling time after connect
      await new Promise((r) => setTimeout(r, 300));
      const text = (PAYLOAD && typeof PAYLOAD.text === "string") ? PAYLOAD.text : "";
      log(`Auto-speak (nonce=${nonce}) text_chars=${text.length}`);
      await speakFlow(text);
    }
  });

})();
</script>
</body>
</html>
