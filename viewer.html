<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LiveAvatar Viewer</title>

  <!-- Requested static include -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/livekit-client/2.15.7/livekit-client.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b0b0b; --panel:rgba(0,0,0,.55); --text:#fff; --muted:rgba(255,255,255,.75);
      --ok:#9AF7B0; --warn:#ffd37a; --bad:#ff8a8a;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    .frame{height:100%; display:grid; grid-template-rows:auto 1fr; gap:10px; padding:12px; box-sizing:border-box;}
    .header{font-size:20px; font-weight:800; opacity:.95}
    .stage{position:relative; width:100%; height:100%; border-radius:18px; overflow:hidden; background:#111;}
    video{width:100%; height:100%; object-fit:cover; background:#111}
    .overlay{position:absolute; left:10px; right:10px; bottom:10px; background:var(--panel);
      border-radius:14px; padding:10px 12px; font-size:12px; line-height:1.35; z-index:6}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{border-radius:999px; padding:4px 10px; background:rgba(255,255,255,.10); color:var(--muted); font-size:12px}
    .pill.ok{color:var(--ok)} .pill.warn{color:var(--warn)} .pill.bad{color:var(--bad)}
    .btn{cursor:pointer; border:0; border-radius:10px; padding:7px 10px; background:rgba(255,255,255,.14); color:var(--text); font-weight:800; font-size:12px}
    .btn:hover{background:rgba(255,255,255,.18)}
    .log{margin-top:8px; max-height:190px; overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space: pre-wrap; color: rgba(255,255,255,.78); font-size:11px}
  </style>
</head>

<body>
  <div class="frame">
    <div class="header">__AVATAR_NAME__ · Live session</div>

    <div class="stage">
      <video id="avatarVideo" autoplay playsinline></video>

      <div class="overlay">
        <div class="row">
          <span id="sdkPill" class="pill">SDK: checking…</span>
          <span id="roomPill" class="pill">Room: idle</span>
          <span id="micPill" class="pill">Mic: off</span>
          <span id="trkPill" class="pill">Tracks: 0</span>
          <button class="btn" id="reconnectBtn" type="button">Reconnect</button>
          <button class="btn" id="micBtn" type="button">Enable Mic</button>
          <button class="btn" id="speakBtn" type="button">Speak</button>
        </div>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

  <script>
    const LIVEKIT_URL = "__LIVEKIT_URL__";
    const LIVEKIT_TOKEN = "__LIVEKIT_TOKEN__";
    const SPEAK_PAYLOAD = __SPEAK_PAYLOAD_JSON__;

    const logEl = document.getElementById("log");
    const sdkPill = document.getElementById("sdkPill");
    const roomPill = document.getElementById("roomPill");
    const micPill = document.getElementById("micPill");
    const trkPill = document.getElementById("trkPill");
    const videoEl = document.getElementById("avatarVideo");

    function log(msg){
      const t=new Date().toISOString().slice(11,19);
      logEl.textContent += `[${t}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setPill(el, text, cls){ el.textContent=text; el.className="pill"+(cls?(" "+cls):""); }

    window.addEventListener("error", (e)=>log(`window.onerror: ${e.message}`));
    window.addEventListener("unhandledrejection",(e)=>log(`unhandledrejection: ${e.reason}`));

    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    // ---- LiveKit SDK loader (static tag may be blocked; try fallbacks) ----
    function findLiveKitSDK(){
      const guesses = [
        window.LivekitClient,   // known working in your earlier run
        window.LiveKitClient,
        window.LiveKit,
        window.livekit,
        window.LiveKitSDK
      ].filter(Boolean);

      for(const g of guesses){
        if(g && g.Room && g.RoomEvent) return { sdk:g, name:"guessed/global" };
      }

      const keys = Object.keys(window).filter(k => /livekit/i.test(k));
      if(keys.length) log("window keys matching /livekit/i: " + keys.join(", "));
      for(const k of keys){
        try{
          const v = window[k];
          if(v && v.Room && v.RoomEvent) return { sdk:v, name:k };
        }catch{}
      }
      return null;
    }

    function loadScript(url){
      return new Promise((resolve, reject)=>{
        const s=document.createElement("script");
        s.src=url; s.async=true;
        s.onload=()=>resolve(true);
        s.onerror=()=>reject(new Error("Failed to load: "+url));
        document.head.appendChild(s);
      });
    }

    async function ensureSDK(){
      let found = findLiveKitSDK();
      if(found){
        setPill(sdkPill, "SDK: loaded", "ok");
        log("LiveKit SDK found via " + found.name);
        return found.sdk;
      }

      setPill(sdkPill, "SDK: loading…", "warn");
      const fallbacks = [
        "https://cdn.jsdelivr.net/npm/livekit-client@2.15.7/dist/livekit-client.umd.min.js",
        "https://unpkg.com/livekit-client@2.15.7/dist/livekit-client.umd.min.js",
      ];
      for(const u of fallbacks){
        try{
          log("Loading SDK: " + u);
          await loadScript(u);
          await sleep(150);
          found = findLiveKitSDK();
          if(found){
            setPill(sdkPill, "SDK: loaded", "ok");
            log("LiveKit SDK found via " + found.name);
            return found.sdk;
          }
          log("Loaded script but still no usable LiveKit global.");
        }catch(e){
          log("Error: " + (e && e.message ? e.message : String(e)));
        }
      }

      setPill(sdkPill, "SDK: missing", "bad");
      log("LiveKit SDK missing in iframe. Check CDN/CSP.");
      return null;
    }

    // ---- LiveKit room + tracks ----
    let LK = null;
    let room = null;
    let remoteVideoTrack = null;
    let remoteAudioTracks = [];
    let localMicTrack = null;

    function trackCount(){
      return (remoteVideoTrack?1:0) + remoteAudioTracks.length + (localMicTrack?1:0);
    }

    function updateTracksPill(){
      const n = trackCount();
      setPill(trkPill, `Tracks: ${n}`, n ? "ok" : "");
    }

    async function connectRoom(){
      LK = await ensureSDK();
      if(!LK){
        setPill(roomPill, "Room: SDK missing", "bad");
        return;
      }

      try{
        setPill(roomPill, "Room: connecting…", "warn");
        log("Connecting to LiveKit…");
        log("URL: " + LIVEKIT_URL);
        log("Token length: " + (LIVEKIT_TOKEN ? LIVEKIT_TOKEN.length : 0));

        room = new LK.Room({ adaptiveStream:true, dynacast:true });

        room.on(LK.RoomEvent.TrackSubscribed, (track, pub, participant)=>{
          log(`TrackSubscribed: kind=${track.kind}, from=${participant.identity}`);

          if(track.kind==="video" && !remoteVideoTrack){
            remoteVideoTrack = track;
            track.attach(videoEl);
            log("Attached avatar video.");
          }

          if(track.kind==="audio"){
            const a=document.createElement("audio");
            a.autoplay=true; a.playsInline=true;
            document.body.appendChild(a);
            track.attach(a);
            track.__audioEl=a;
            remoteAudioTracks.push(track);
            log("Attached avatar audio.");
          }

          updateTracksPill();
        });

        room.on(LK.RoomEvent.Disconnected, (reason)=>{
          setPill(roomPill, "Room: disconnected", "bad");
          log("Disconnected: " + reason);
        });

        room.on(LK.RoomEvent.DataReceived, (payload, participant, kind, topic)=>{
          try{
            const txt = new TextDecoder().decode(payload);
            log(`DataReceived from=${participant?.identity || "?"} topic=${topic||""}: ${txt}`);
          }catch{
            log("DataReceived (binary)");
          }
        });

        const connectDelay = Number(SPEAK_PAYLOAD?.connect_delay_ms || 0);
        if(connectDelay > 0){
          log(`Connect delay: waiting ${connectDelay}ms…`);
          await sleep(connectDelay);
        }

        await room.connect(LIVEKIT_URL, LIVEKIT_TOKEN);

        setPill(roomPill, "Room: connected", "ok");
        log("Connected.");
        updateTracksPill();
      }catch(e){
        setPill(roomPill, "Room: error", "bad");
        log("Connect error: " + (e && e.message ? e.message : String(e)));
      }
    }

    // ---- Mic publish (audio only) ----
    async function enableMic(){
      if(!LK || !room || !room.localParticipant){
        log("Mic blocked: room not ready.");
        return;
      }
      try{
        setPill(micPill, "Mic: requesting…", "warn");
        localMicTrack = await LK.createLocalAudioTrack();
        await room.localParticipant.publishTrack(localMicTrack);
        setPill(micPill, "Mic: ON", "ok");
        log("Local microphone published.");
        updateTracksPill();
      }catch(e){
        setPill(micPill, "Mic: denied", "bad");
        log("Mic error: " + (e && e.message ? e.message : String(e)));
      }
    }

    // ---- Command events: interrupt -> wait -> speak_text ----
    async function sendCommand(obj){
      if(!room || !room.localParticipant){
        log("Command blocked: room not connected.");
        return;
      }
      const bytes = new TextEncoder().encode(JSON.stringify(obj));
      await room.localParticipant.publishData(bytes, { reliable:true });
    }

    async function interruptThenSpeak(){
      const text = (SPEAK_PAYLOAD && SPEAK_PAYLOAD.text) ? String(SPEAK_PAYLOAD.text) : "";
      if(!text.trim()){
        log("Speak blocked: empty text.");
        return;
      }
      try{
        if(!!SPEAK_PAYLOAD?.interrupt_before_speak){
          await sendCommand({ event:"avatar.interrupt", data:{} });
          log("Command sent: avatar.interrupt");
          await sleep(Number(SPEAK_PAYLOAD?.interrupt_delay_ms || 500));
        }
        await sendCommand({ event:"avatar.speak_text", data:{ text } });
        log(`Command sent: avatar.speak_text (chars=${text.length})`);
      }catch(e){
        log("Speak error: " + (e && e.message ? e.message : String(e)));
      }
    }

    // ---- Buttons ----
    document.getElementById("reconnectBtn").addEventListener("click", async ()=>{
      log("Reconnect pressed.");
      try{ if(room) await room.disconnect(); }catch{}
      room=null; LK=null; localMicTrack=null;
      setPill(micPill, "Mic: off", "");
      setPill(roomPill, "Room: idle", "");
      setPill(sdkPill, "SDK: checking…", "");
      remoteVideoTrack=null; remoteAudioTracks=[];
      updateTracksPill();
      await connectRoom();
    });

    document.getElementById("micBtn").addEventListener("click", enableMic);
    document.getElementById("speakBtn").addEventListener("click", interruptThenSpeak);

    // ---- Boot ----
    (async ()=>{
      log("Viewer boot.");
      log("Payload: nonce=" + (SPEAK_PAYLOAD ? SPEAK_PAYLOAD.nonce : "null"));
      await connectRoom();

      if(SPEAK_PAYLOAD?.publish_microphone){
        await sleep(300);
        log("Auto: enabling mic …");
        await enableMic();
      }
    })();
  </script>
</body>
</html>
