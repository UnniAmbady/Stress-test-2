<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>__AVATAR_NAME__ · Live session</title>

  <!-- LiveKit UMD -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/livekit-client/2.15.7/livekit-client.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b0b0b;--panel:rgba(0,0,0,.60);--text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);--ok:#a4ffce;--bad:#ff6b6b;--warn:#ffd166;
      --r:18px
    }
    html,body{margin:0;padding:0;background:transparent;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .frame{background:var(--bg);border-radius:var(--r);overflow:hidden;position:relative;height:560px;width:100%}
    .header{position:absolute;top:0;left:0;right:0;padding:12px 14px;
      background:linear-gradient(to bottom,rgba(0,0,0,.75),rgba(0,0,0,0));
      color:var(--text);font-weight:700;z-index:5}
    .stage{position:absolute;inset:0;display:grid;place-items:center}
    video{width:100%;height:100%;object-fit:cover;background:#111}
    .overlay{position:absolute;left:10px;right:10px;bottom:10px;background:var(--panel);
      color:var(--text);border-radius:14px;padding:10px 12px;font-size:12px;line-height:1.35;z-index:6}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{border-radius:999px;padding:4px 10px;background:rgba(255,255,255,.10);color:var(--muted);font-size:12px}
    .pill.ok{color:var(--ok)} .pill.warn{color:var(--warn)} .pill.bad{color:var(--bad)}
    .btn{cursor:pointer;border:0;border-radius:10px;padding:7px 10px;background:rgba(255,255,255,.14);color:var(--text);font-weight:700;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.18)}
    .log{margin-top:8px;max-height:150px;overflow:auto;
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      white-space:pre-wrap;color:rgba(255,255,255,.78);font-size:11px}
  </style>
</head>

<body>
  <div class="frame">
    <div class="header">__AVATAR_NAME__ · Live session</div>

    <div class="stage">
      <video id="avatarVideo" autoplay playsinline></video>
    </div>

    <div class="overlay">
      <div class="row">
        <span id="sdkPill" class="pill">SDK: checking…</span>
        <span id="roomPill" class="pill">Room: idle</span>
        <span id="micPill" class="pill">Mic: off</span>
        <span id="trkPill" class="pill">Tracks: 0</span>
        <button class="btn" id="reconnectBtn" type="button">Reconnect</button>
        <button class="btn" id="micBtn" type="button">Enable Mic</button>
        <button class="btn" id="speakBtn" type="button">Speak</button>
      </div>
      <div class="log" id="log"></div>
    </div>
  </div>

  <script>
    const LIVEKIT_URL = "__LIVEKIT_URL__";
    const LIVEKIT_TOKEN = "__LIVEKIT_TOKEN__";
    const SPEAK_PAYLOAD = __SPEAK_PAYLOAD_JSON__;

    const logEl = document.getElementById("log");
    const sdkPill = document.getElementById("sdkPill");
    const roomPill = document.getElementById("roomPill");
    const micPill = document.getElementById("micPill");
    const trkPill = document.getElementById("trkPill");
    const videoEl = document.getElementById("avatarVideo");
    const reconnectBtn = document.getElementById("reconnectBtn");
    const micBtn = document.getElementById("micBtn");
    const speakBtn = document.getElementById("speakBtn");

    function log(msg){
      const t=new Date().toISOString().slice(11,19);
      logEl.textContent += `[${t}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setPill(el, text, cls){ el.textContent=text; el.className="pill"+(cls?(" "+cls):""); }

    window.addEventListener("error", (e)=>log(`window.onerror: ${e.message}`));
    window.addEventListener("unhandledrejection",(e)=>log(`unhandledrejection: ${e.reason}`));

    // -------- Robust LiveKit SDK discovery (this is the fix) --------
    function findLiveKitSDK(){
      const guesses = [
        window.LivekitClient,    // <-- the one you saw earlier
        window.LiveKitClient,
        window.LiveKit,
        window.livekit,
        window.livekitClient,
        window.LiveKitSDK,
        window.Livekit
      ].filter(Boolean);

      for(const g of guesses){
        if(g && g.Room && g.RoomEvent) return { sdk:g, name:"guessed" };
      }

      const keys = Object.keys(window);
      const hits = keys.filter(k => /livekit/i.test(k));
      if(hits.length) log("window keys matching /livekit/i: " + hits.join(", "));

      for(const k of hits){
        try{
          const v = window[k];
          if(v && v.Room && v.RoomEvent) return { sdk:v, name:k };
        }catch{}
      }
      return null;
    }

    async function ensureSDK(){
      let found = findLiveKitSDK();
      if(found){
        setPill(sdkPill, "SDK: loaded", "ok");
        log("LiveKit SDK found via " + found.name);
        return found.sdk;
      }
      setPill(sdkPill, "SDK: missing", "bad");
      log("LiveKit SDK missing in iframe. Check CDN / CSP.");
      return null;
    }

    // -------- LiveKit room + tracks --------
    let LK = null;
    let room = null;
    let remoteVideoTrack = null;
    let remoteAudioTracks = [];
    let localMicTrack = null;

    function detachAll(){
      try{
        if(remoteVideoTrack){ remoteVideoTrack.detach(videoEl); remoteVideoTrack=null; }
        remoteAudioTracks.forEach(t=>{
          try{
            t.__audioEl && t.detach(t.__audioEl);
            t.__audioEl && t.__audioEl.remove();
          }catch{}
        });
        remoteAudioTracks=[];
      }catch{}
      setPill(trkPill, "Tracks: 0", "");
    }

    function trackCount(){
      return (remoteVideoTrack?1:0) + remoteAudioTracks.length + (localMicTrack?1:0);
    }

    async function connectRoom(){
      detachAll();
      LK = await ensureSDK();
      if(!LK){ setPill(roomPill, "Room: SDK missing", "bad"); return; }

      try{
        setPill(roomPill, "Room: connecting…", "warn");
        log("Connecting to LiveKit…");
        log("URL: " + LIVEKIT_URL);
        log("Token length: " + (LIVEKIT_TOKEN ? LIVEKIT_TOKEN.length : 0));

        room = new LK.Room({ adaptiveStream:true, dynacast:true });

        room.on(LK.RoomEvent.TrackSubscribed, (track, pub, participant)=>{
          log(`TrackSubscribed: kind=${track.kind}, from=${participant.identity}`);

          if(track.kind==="video" && !remoteVideoTrack){
            remoteVideoTrack = track;
            track.attach(videoEl);
            log("Attached avatar video.");
          }

          if(track.kind==="audio"){
            const a=document.createElement("audio");
            a.autoplay=true; a.playsInline=true;
            document.body.appendChild(a);
            track.attach(a);
            track.__audioEl=a;
            remoteAudioTracks.push(track);
            log("Attached avatar audio.");
          }

          setPill(trkPill, `Tracks: ${trackCount()}`, trackCount()? "ok": "");
        });

        room.on(LK.RoomEvent.Disconnected, (reason)=>{
          setPill(roomPill, "Room: disconnected", "bad");
          log("Disconnected: " + reason);
        });

        // Helpful: log any data coming back (acks/errors if they exist)
        room.on(LK.RoomEvent.DataReceived, (payload, participant, kind, topic)=>{
          try{
            const txt = new TextDecoder().decode(payload);
            log(`DataReceived from=${participant?.identity || "?"} topic=${topic||""} kind=${kind}: ${txt}`);
          }catch(e){
            log("DataReceived (binary) from=" + (participant?.identity||"?"));
          }
        });

        await room.connect(LIVEKIT_URL, LIVEKIT_TOKEN);
        setPill(roomPill, "Room: connected", "ok");
        log("Connected.");

        setPill(trkPill, `Tracks: ${trackCount()}`, trackCount()? "ok": "");

      }catch(e){
        setPill(roomPill, "Room: error", "bad");
        log("Connect error: " + (e && e.message ? e.message : String(e)));
      }
    }

    // -------- Mic ON (publish local audio track) --------
    async function enableMic(){
      if(!LK || !room || !room.localParticipant){
        log("Mic blocked: room not ready.");
        return;
      }
      try{
        setPill(micPill, "Mic: requesting…", "warn");
        localMicTrack = await LK.createLocalAudioTrack();
        await room.localParticipant.publishTrack(localMicTrack);
        setPill(micPill, "Mic: ON", "ok");
        log("Local microphone published.");
        setPill(trkPill, `Tracks: ${trackCount()}`, "ok");
      }catch(e){
        setPill(micPill, "Mic: denied", "bad");
        log("Mic error: " + (e && e.message ? e.message : String(e)));
      }
    }

    // -------- Command events experiment: interrupt -> wait 500ms -> speak_text --------
    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    async function sendCommand(obj){
      if(!room || !room.localParticipant){
        log("Command blocked: room not connected.");
        return;
      }
      const bytes = new TextEncoder().encode(JSON.stringify(obj));
      await room.localParticipant.publishData(bytes, { reliable:true });
    }

    async function interruptThenSpeak(){
      const text = (SPEAK_PAYLOAD && SPEAK_PAYLOAD.text) ? String(SPEAK_PAYLOAD.text) : "";
      if(!text.trim()){
        log("Speak blocked: empty text.");
        return;
      }
      try{
        // interrupt
        await sendCommand({ event:"avatar.interrupt", data:{} });
        log("Command sent: avatar.interrupt");

        // wait
        await sleep(500);

        // speak
        await sendCommand({ event:"avatar.speak_text", data:{ text } });
        log(`Command sent: avatar.speak_text (chars=${text.length})`);
      }catch(e){
        log("Speak pipeline error: " + (e && e.message ? e.message : String(e)));
      }
    }

    // -------- UI hooks --------
    reconnectBtn.addEventListener("click", async ()=>{
      log("Reconnect pressed.");
      try{ if(room) await room.disconnect(); }catch{}
      room=null; LK=null; localMicTrack=null;
      setPill(micPill, "Mic: off", "");
      await connectRoom();
    });

    micBtn.addEventListener("click", enableMic);
    speakBtn.addEventListener("click", interruptThenSpeak);

    // -------- boot --------
    (async ()=>{
      log("Viewer boot.");
      log("Payload: nonce=" + (SPEAK_PAYLOAD ? SPEAK_PAYLOAD.nonce : "null"));
      await connectRoom();
    })();
  </script>
</body>
</html>
